#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel MAIN_1 main=MAIN_1 SCATTERING_ORDER=1
#pragma kernel MAIN_N main=MAIN_N

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PbrSky/PbrSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"

#define TABLE_SIZE uint3(PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_X, \
                         PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Y, \
                         PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Z)

RW_TEXTURE3D(float4, _InScatteredRadianceTable); // Emulate a 4D texture with a "deep" 3D texture


float2 IntersectRayCylinder(float3 cylOrigin, float3 cylAxis, float cylRadiusSquared,
                            float3 rayOrigin, float3 rayDir)
{
    float3 start = rayOrigin - cylOrigin;

    float c1 = dot(cylAxis, rayDir);
    float c2 = dot(cylAxis, start);

    // Solve: t^2 + 2 * (b / a) * t + (c / a) = 0.
    float a = 1.0 - c1 * c1;
    float b = rcp(a) * (dot(start, rayDir) - c2 * c1);
    float c = rcp(a) * (dot(start, start) - c2 * c2 - cylRadiusSquared);

    float d = b * b - c;

    return ((abs(a) < FLT_EPS) || (d < 0)) ? -1 : float2(-b - sqrt(d),
                                                         -b + sqrt(d));
}

[numthreads(4, 4, 4)]
void main(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    const uint zTexSize = PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_Z;
    const uint zTexCnt  = PBRSKYCONFIG_IN_SCATTERED_RADIANCE_TABLE_SIZE_W;

    // We don't care about the extremal points for XY, but need the full range of Z values.
    const float3 scale = rcp(float3(TABLE_SIZE.xy, 1));
    const float3 bias  = float3(0.5 * scale.xy, 0);

    // Let the hardware and the driver handle the ordering of the computation.
    uint3 tableCoord = dispatchThreadId;
    uint  texId      = tableCoord.z / zTexSize;       // [0, zTexCnt  - 1]
    uint  texCoord   = tableCoord.z & (zTexSize - 1); // [0, zTexSize - 1]

    float3 uvw = tableCoord * scale + bias;

    // Convention:
    // V points towards the camera.
    // The normal vector N points upwards (local Z).
    // The view vector V spans the local XZ plane.
    // The light vector is represented as {phiL, cosThataL} w.r.t. the XZ plane.
    float cosChi = UnmapAerialPerspective(uvw.xy).x;
    float height = UnmapAerialPerspective(uvw.xy).y;
    float cosHor = GetCosineOfHorizonZenithAngle(height);
    float phiL   = PI * saturate(texCoord * rcp(zTexSize - 1));
    float NdotL  = UnmapCosineOfZenithAngle(saturate(texId * rcp(zTexCnt - 1)));

    float NdotV  = -cosChi;

    bool lookAboveHorizon = (cosChi > cosHor);

    float3 N = float3(0, 0, 1);
    float3 V = SphericalToCartesian(0, NdotV);
    float3 L = SphericalToCartesian(phiL, NdotL);

    float LdotV = dot(L, V);
    // float LdotV = SphericalDot(NdotL, phiL, NdotV, 0);

    // Set up the ray...
    float  h = height;
    float  R = _PlanetaryRadius;
    float  r = h + R;
    float3 O = float3(0, 0, r);

    // Determine the region of integration.
    float tMin = 0;
    float tMax;

    if (lookAboveHorizon)
    {
        float _AtmosphericRadius = _PlanetaryRadius + _AtmosphericDepth;
        tMax = IntersectSphere(_AtmosphericRadius, cosChi, r).y; // Max root
    }
    else
    {
        tMax = IntersectSphere(_PlanetaryRadius,   cosChi, r).x; // Min root
    }

    float3 radiance   = 0;
    float4 tableEntry = float4(radiance, 0);

#if (SCATTERING_ORDER == 1)
    // For single scattering with the directional light assumption, planet's shadow forms a shadow volume
    // which is shaped like a cylinder with the planet's radius, aligned with the light direction.
    // We can use it to optimize the integration process, as the shadowed region has 0 contribution.

    float2 tCyl = IntersectRayCylinder(0, L, _PlanetaryRadiusSquared, O, -V);

    if (tCyl.y >= 0) // Exited?
    {
        // We found an intersection with the shadow volume.
        // It could be either the entry or the exit.

        if (tCyl.x >= 0) // Entered?
        {
            float zHit = dot(L, O + tCyl.x * -V);

            if (zHit < 0) // Below?
            {
                // Stop the ray at the entry.
                // We assume that the ray does not exit the shadow volume before exiting the atmosphere.
                // The error of that assumption should be reasonably low.
                tMax = min(tMax, tCyl.x);
            }
        }

        bool inShadow = (L.z < 0);

        if (inShadow)
        {
            // Start the ray at the exit.
            tMin = max(tMin, tCyl.y);
        }
    }

    if (tMin >= tMax)
    {
        tableEntry.a = tMax - tMin;
        _InScatteredRadianceTable[tableCoord] = tableEntry; // Return 0
        return;
    }

    // Integrate in-scattered radiance along -V.
    // Note that we have to evaluate the transmittance integral along -V as well.
    // The transmittance integral is pretty smooth (I plotted it in Mathematica).
    // However, using a non-linear distribution of samples is still a good idea both
    // when looking up (due to the exponential falloff of the coefficients)
    // and for horizontal rays (due to the exponential transmittance term).
    // It's easy enough to use a simple quadratic remap.

    float  t0          = tMin;
    float3 viewTransmX = SampleTransmittanceTexture(cosChi, height); // Start to end
    float3 viewTransm0 = 1;

    if (tMin > 0) // Start changed?
    {
        float3 P = O + tMin * -V;

        // Update these for the step along the ray...
        height = length(P) - R;
        cosChi = dot(normalize(P), -V);
        NdotL  = dot(normalize(P),  L);

        // TODO: maybe better to use optical depth?
        viewTransm0 = viewTransmX * rcp(SampleTransmittanceTexture(cosChi, height)); // Start to sample
    }

    float3 inScatterTerm0;

    // TODO: we don't have to apply the phase function here.
    // It's a better idea to apply it when sampling the texture.
    {
        float3 lightScatter = AtmosphereScatter(LdotV, height);
        float3 lightTransm  = SampleTransmittanceTexture(NdotL, height);

        inScatterTerm0 = viewTransm0 * lightScatter * lightTransm;
    }

    // const int numSamples = 4096;
    const int numSamples = 256;
    for (int i = 0; i < numSamples; i++)
    {
        float t1 = tMin + (tMax - tMin) * Sq((i + 1) * rcp(numSamples));
        float dt = t1 - t0;

        float3 P = O + t1 * -V;

        // Update these for the step along the ray...
        height = length(P) - R;
        cosChi = dot(normalize(P), -V);
        NdotL  = dot(normalize(P),  L);

        // TODO: maybe better to use optical depth?
        float3 viewTransm   = viewTransmX * rcp(SampleTransmittanceTexture(cosChi, height));
        float3 lightScatter = AtmosphereScatter(LdotV, height);
        float3 lightTransm  = SampleTransmittanceTexture(NdotL, height);

        float3 inScatterTerm1 = viewTransm * lightScatter * lightTransm;

        // Compute the amount of in-scattered radiance.
        // Evaluate the transmittance integral from 't0' to 't1' using the trapezoid rule.
        // Integral{a, b}{Transmittance(0, t) dt} â‰ˆ
        // (Transmittance(0, a) + Transmittance(0, b)) * (b - a) / 2 =
        // (Transmittance(0, a) + Transmittance(0, tMax) / Transmittance(b, tMax)) * (b - a) / 2.
        // We handle other terms in a similar way (by pre-multiplying transmittance).
        radiance += (inScatterTerm0 + inScatterTerm1) * (0.5 * dt) * _SunRadiance;

        // Carry these over to the next iteration...
        t0             = t1;
        inScatterTerm0 = inScatterTerm1;
    }
#endif

    // if (NdotL > cosHor)
    // {
    //     // Sun is directly visible from this position.
    //     float3 transm  = SampleTransmittanceTexture(NdotL, height, false);
    //     float3 scatter = AtmosphereScatter(LdotV, height);

    //     radiance += scatter * transm * _SunRadiance;
    // }
    // else
    // {
    //     // The sun is occluded by the planet.
    // }

    // // Integrate ground contribution.
    // // The ground is a Lambertian reflector. It is basically a textured sphere light.
    // // TODO: a lot of values are almost zero! How to early-out?
    // {
    //     // We will importance sample according to the solid angle.
    //     // Hard to take transmittance, the phase function and the illumination into account...
    //     float R = _PlanetaryRadius;
    //     float h = height;
    //     float r = R + h;

    //     float3 P           = r * N;
    //     float  cosAperture = -cosHor; // Cosine of the half-angle

    //     const int numGroundSamples = 89;

    //     for (int i = 0; i < numGroundSamples; i++)
    //     {
    //         float2 f = Fibonacci2d(i, numGroundSamples);

    //         // Construct a direction around the up vector.
    //         float3 dir; float rcpPdf;
    //         SampleCone(f, cosAperture, dir, rcpPdf);

    //         // Flip it upside-down to point towards the sphere light (planet).
    //         float3 gL = -dir;

    //         // TODO: compute analytically?
    //         float  t  = IntersectPlanetFromOutside(gL.z, h);
    //         float3 gP = P + t * gL;
    //         float3 gN = normalize(gP);

    //         // Shade the ground.
    //         const float3 gBrdf = INV_PI * _GroundAlbedo;

    //         float3 transm  = SampleTransmittanceTexture(gL.z, h, true);
    //         float3 scatter = AtmosphereScatter(dot(gL, V), h);

    //         float weight = rcpPdf * rcp(numGroundSamples);
    //         radiance += weight * scatter * transm * gBrdf * SampleGroundIrradianceTexture(dot(gN, L));
    //     }
    // }

    // TODO: deep compositing.
    tableEntry = float4(radiance, tMax - tMin);
    // tableEntry = float4(radiance, tMax);
    // tableEntry = float4(cosChi, h, NdotL, tMax);
    // tableEntry = float4(viewTransmX, tMax);

    _InScatteredRadianceTable[tableCoord] = tableEntry;
}
