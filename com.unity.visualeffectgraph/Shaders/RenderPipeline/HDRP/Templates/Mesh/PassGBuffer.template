Pass
{		
	Tags { "LightMode"="GBuffer" }
	
	Stencil
	{
		WriteMask 7
		Ref  2
		Comp Always
		Pass Replace
	}	
		
	HLSLPROGRAM
	#pragma target 4.5
	
	#pragma multi_compile _ LIGHT_LAYERS
	#pragma multi_compile _ DEBUG_DISPLAY
	
	#define UNITY_MATERIAL_LIT
	
	${VFXInclude("Shaders/RenderPipeline/HDRP/VFXLitVaryings.template")}	
	
	struct ps_input
	{
		float4 pos : SV_POSITION;
		
		${VFXHDRPLitDeclareVaryings}
		
		#if USE_FLIPBOOK_INTERPOLATION
		float4 uv : TEXCOORD1;
		#else
		float2 uv : TEXCOORD1;	
		#endif
		float3 normal : TEXCOORD2;
		#if USE_NORMAL_MAP
		float4 tangent : TEXCOORD3;
		#endif
		#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION
		// x: inverse soft particles fade distance
		// y: alpha threshold
		// z: frame blending factor
		nointerpolation float3 builtInInterpolants : TEXCOORD4;
		#endif
	};
	
	struct ps_output
	{
		float4 color : SV_Target0;
	};

${VFXHDRPLitVaryingsMacros}
	
#define VFX_VARYING_PS_INPUTS ps_input
#define VFX_VARYING_POSCS pos
#define VFX_VARYING_UV uv
#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
#define VFX_VARYING_NORMAL normal
#if USE_NORMAL_MAP
#define VFX_VARYING_TANGENT tangent
#endif

${VFXBegin:VFXVertexAdditionalProcess}
${VFXHDRPLitFillVaryings}
${VFXEnd}

	${VFXInclude("Shaders/ParticleMeshes/Pass.template")}	
	#define SHADERPASS SHADERPASS_GBUFFER	
	${VFXInclude("Shaders/RenderPipeline/HDRP/VFXLit.template")}	
#if SHADER_GRAPH

    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/VertMesh.hlsl"
    
    $(VFXShaderGraphInput_GBuffer)

    void Frag( PackedVaryingsToPS packedInput,OUTPUT_GBUFFER(outGBuffer))
    {
        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);
        FragInputs input = UnpackVaryingsMeshToFragInputs(packedInput.vmesh);

        // input.positionSS is SV_Position
        PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);

    #ifdef VARYINGS_NEED_POSITION_WS
        float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);
    #else
        // Unused
        float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0
    #endif

        SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                
        SurfaceData surfaceData;
        BuiltinData builtinData;
        float3 bentNormalWS;
        BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);

        // Builtin Data
        // For back lighting we use the oposite vertex normal 
        InitBuiltinData(surfaceDescription.Alpha, bentNormalWS, -fragInputs.worldToTangent[2], fragInputs.positionRWS, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);
        
        // override sampleBakedGI:

        builtinData.emissiveColor = surfaceDescription.Emission;

        // TODO: Handle depth offset
        //builtinData.depthOffset = 0.0;

#if (SHADERPASS == SHADERPASS_DISTORTION)
        builtinData.distortion = surfaceDescription.Distortion;
        builtinData.distortionBlur = surfaceDescription.DistortionBlur;
#else
        builtinData.distortion = float2(0.0, 0.0);
        builtinData.distortionBlur = 0.0;
#endif

        PostInitBuiltinData(V, posInput, surfaceData, builtinData);

        ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);
    }

#else		
	#pragma fragment frag
	void frag(ps_input i, OUTPUT_GBUFFER(outGBuffer)
#if USE_DOUBLE_SIDED
	, bool frontFace : SV_IsFrontFace
#endif
	)
	{
		${VFXComputeNormalWS}
		VFXComputePixelOutputToGBuffer(i,normalWS,uvData,outGBuffer);
	}
	ENDHLSL
#endif
}
